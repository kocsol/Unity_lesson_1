12/13
객체선정 Person
추상화
사람인데 나이가~
키가~
남자 여자
남 혹 여
이름

설계도 제작(클래스화)
객체생성(객체화)
인스턴스생성 (인스턴스화)

클래스는
사물, 동작이나 기능을 포함한 사물, 개념

-클래스는 대문자 시작
변수는 소문자 시작. 대신 단어 바뀔때마다 대문자로
함수도 대문자

2021/12/15
클라스 오브젝트 인스턴스 예제 하나 더만들어 보기

객체선정 
Orc

추상화
Orc의 특징
Orc의 이름은 상급오크다
Orc는 키가 240.2cm다
Orc는 몸무게가 200kg 이다.
Orc는 나이가 140살이다.
Orc의 성별은 남자다.
Orc는 현재 놀고있는가? 아니다.

-Orc의 기능-
Orc는 휘두르기를 할 수 있다.
Orc는 점프를 할 수 있다.

클래스화
객체화 
인스턴스화

Orc 1 특징
Orc의 이름은 상급오크다
Orc는 키가 240.2cm다
Orc는 몸무게가 200kg 이다.
Orc는 나이가 140살이다.
Orc의 성별은 남자다.
Orc는 현재 놀고있는가? 아니다.

Orc 2 특징
Orc의 이름은 하급오크다
Orc는 키가 140.4cm다
Orc는 몸무게가 120kg 이다.
Orc는 나이가 60살이다.
Orc의 성별은 여자다.
Orc는 현재 놀고있는가? 예

오크1을 점프시키고
오크1을 휘두리기 시키고
오크2를 점프시키고
오크2는 휘두르기를 시킴

2021/12/20
연산자



21/12/22
git hub 사용법
1.학원에서 작업
2.학원 컴퓨터 git desktop에 changes로 뜨고 
3.commit하면 history에 올라가고 push

-> 이 과정을 거치면 git hub 클라우드 서버에 올라감

1. 집 pc를 보면 pull할게 있다고 뜸. 
2. 하면됨
1. 그런데 pull and push라고 뜨면 필요한 내용을 백업(다른 폴더에 사본을 만들어 놓음) 
2. change 우클릭 discard, (코밋했으면 코밋한거에 우클릭 undo commit 취소됨)
3. 그러면 pull만뜸 
4. 그러면 원래 있던 건. 필요한 폴더]
더 궁금한것 git hub 사용법 인터넷에 쳐서 알아보기

오늘 할 것
1. 함수 오버로딩
2. 배열
3. 반복문 (while, for)

1.함수 오버로딩 쉽게 말하면 함수 하나가 여러가지 메소드를 사용할 수 잇게

2. 배열 : 정적 데이터 공간

3. 반복문 
while, for, Do While(실제로 쓰는 경우가 거의 없음), For each(나중)
분기문
if, switch- case


2021/12/24
for loop 예제
 
디버깅 - 버그를 찾자

F9(중단점)를 누른후 F5를 실행하면 F9로 지정된 곳 까지만 실행이 됨
F10은 코드를 한 줄씩 진행
이를 통해 오류를 찾자

2021/12/27
Enum에 대한 공부를 함
이것도 리스트나 그런것과 같은 자료 열거형임 여러가지 자료를 넣어놈 

원래 Enum은 정수 1234 순이지만 flag로 해서 더 편의적으로 해당 동작을 더 하거나 할 수 도 있으니
 enum 자체는 지정안해도 정수1234 지정 하지만 중복적인 형태를 사용할때 문제가 생기니
flags로 새롭게 지정해서 중복 사용가능
enum 타입을 switch 형으로 쓰면 열거형이라 편하게 나옴 

2021/12/29
structure : 구조체

구조체 자체는 하나의 자료형이라 생각하면 됨 int, string 등과 같이 우리가 int =3 이렇게 하지 않고 int a =3 이라고 쓰듯이
그래서 구조체를 사용할 때 변수를 새로 만들어 줘서 사용

Class 세부적인 설명

생성자와 소멸자, 가비지 컬렉션 
상속과 다형성 (오버라이딩, 인터페이스)
SOLID 원칙

C# 상속 한번 읽고 공부하고 와보자

2022/01/05
클래스 심화

1. 생성자. 소멸자. 가비지 컬렉션
2. 상속(inheritance)과 다형성 (오버라이딩, 인터페이스)
3. SOLID 원칙

상속. 요소들에 공통적인 부분을 모아서 하나의 클래스로 만들어서 해당 클래스에 상속받는 형식으로 하여 사용하기 편하게
상속 받는 클래스 자식 상속 해주는 클래스. 부모 이 관계를 상속관계

상속관계를 만드는 이유
많은 클래스들의 공통적인 기능. 정보를 필요로 하는 경우
새, 개 , 사람 등 동물의 수많은 동물에 대한 클래스를 만들었고
이 모든 동물들을 숨쉬기 하는 기능이 있다.
근데 숨쉬기 하는 기능에 대해 수정하거나 삭제하는 경우
수 많은 동물 클래스를ㄹ 하나하나 다 소멸해야한다.
하지만 위 처럼 숨쉬기 기능을 상속 받은 경우에 creature의 숨쉬기하는 기능을 변경하면 아래 모든 동물 크래스들이 똑같이 적용 받으 수 있다.

핵심! 공통적인 요소를 클래스마다 하나 하나 수정하거나 작성 하는 것이 아니라 상속을 만들어 즉 부모 클래스를 만들어 이를 편하게 사용할 수 있다.

인터페이스 아직 애매함 더 자세히 알아보기 위해 구글에 검색해보자

3. SOLID 원칙
프로그램을 할 때 꼭 지켜야하는 규칙
객체지향 프로그래밍을 할 떄 반드시 지켜주어야 하는 5가지 원칙

1. SRP( Single Responsibility Principle 단일 책임 원칙) 

한 클래스는 하나의 책임만 가져야 한다. 여러가지 기능이나 개념을 한 클래스에 담으면 수정하기 불편하고 각 클래스에 대한 확장성, 가독성이 떨어짐

2. OCP( Open Close Principle 개방 폐쇄의 원칙)

재사용 가능하고 관리하기 편한 코드를 만들기 위한 원칙
컴포넌트, 클래스, 모듈, 함수 의 확장에는 열려있고 변경에는 닫혀있어야 한다.
-->레고 블록을 처음에 다양하고 정확하게 설계해서 레고끼리 조립 호환성을 높게 설계한다.
조립 도중에 레고ㅡㄹ록이 안맞다고 해서 레코 블록 자체를 자르거나 불로 녹이는 등의 행위를 하면 안된다.

3. LSP( the Liskov Subsititution Principle 리스코프 치환 법칙)

  하위 타입(정사각형)은 기반 타입(직사각형)으로 언제든지 교체할 수 있어야 한다.
 기반은 부모클래스로부터 상속받은 하위인 자식 클래스가 함수를 오버라이드 해서 사용 할 경우, 언제든지 오버라이드된 함수를 지워서 기반이 부모의 원 함수로 교체 할 수 있어야 함.
(교체 한 후에도 코드가 문제없이 동작해야한다는 뜻)
리스코프 치환법칙을 지키기 위해서는 특히 다음 4가지를 지키면 된다.
  1) 두 객체가 똑같은 일을 수행한다면
--> 클래스는 하나로 만들고 각 객체를 구분지을 수 있는 변수를 만든다.
 2) 기능 이름이 같고 동작은 비슷하나 약간의 차이가 있다면
- > 인터페이스를 구현해서 공통으로 상속받는다.
3)같은 기능을 가지지 않는다면 
--> 두 객체는 각 각 별개의 클래스로 구현함
4) 추가적인 기능을 부여해야 한다면
-->상속을 이용한다.

4.ISP(Interface Sergregration Principle 인터페이스 분리 법칙)

사용하지 않을 인터페이스는 구현하면 안되고,
하나의 일반적인 인터페스보다 여러개의 구체적인 인터페이스를 추구함
IPointerEvenet(유니티에서 클릭으로 하는 인터페이스) 라는 인터페이스 보다 IpointerDownEvent IpointerUpEvent, IPointerClickEvent 등으로 세분화 하는게 좋다.

5. DIP( Dependency Inversion Principle  의존성 역전의 원칙)

자신보다 변하기 쉬운것에 의존하지 마라








